[
{
	"uri": "https://tinyvmi.github.io/quick-start-windows/",
	"title": "Quick Start with Windows Guest",
	"tags": [],
	"description": "",
	"content": " NOTE This post shows all the comands and configuration files you need to build and run TinyVMI with Windows guest. Most of them can be used directly in your terminal on host machine (tested with Ubuntu 16.04, 18.04 as Dom0), while some fields need to be adjusted according to your build environment. For example, your working directory WORKDIR, logical volume group name vg0, iso image file path, etc.\nAcknowledgment: This post is customized for TinyVMI based on instructions at DRAKVUF.\n  1. Install Xen Compile and install Xen from given source code of xen-4.10.0, with XSM enabled.\nmkdir WOKRDIR cd WORKDIR/ # install prerequest for Ubuntu wget https://gist.githubusercontent.com/cnlelema/5f14675364a47c6ffa7e34bb6d3ad470/raw/41cffdbc8d0c689e8d9ba78d886a215125d833d9/install-pre-ubu18-xen4.10.0.sh sudo bash install-pre-ubu18-xen4.10.0.sh # download Xen source git clone --recurse-submodules https://github.com/tinyvmi/xen.git cd xen # configure xen ./configure --enable-stubdom --enable-systemd # enable XSM support make -C xen menuconfig # Mark option # \u0026#39;Common Features -\u0026gt; Xen Security Modules support\u0026#39;, and # suboption \u0026#39;Compile Xen with a built-in security policy\u0026#39;. # leave other option as is.  # compile \u0026amp; install Xen make dist -jN #set N to be number of cores/threads on your machine. sudo make install sudo systemctl enable xen-qemu-dom0-disk-backend.service sudo systemctl enable xen-init-dom0.service sudo systemctl enable xenconsoled.service sudo ldconfig # enable XSM flask in grub entry options  # backup sudo cp /etc/default/grub /etc/default/grub-backup # Add the following line to the file /etc/default/grub: # GRUB_CMDLINE_XEN_DEFAULT=\u0026#34;dom0_mem=3096M,max:3096M flask=enforcing\u0026#34; # This will be appended to the option of Linux kernel in the grub entry sudo sed -i \u0026#39;/GRUB_CMDLINE_LINUX=/aGRUB_CMDLINE_XEN_DEFAULT=\\\u0026#34;dom0_mem=3096M,max:3096M flask=enforcing\\\u0026#34;\u0026#39; /etc/default/grub sudo update-grub # Finally reboot and choose Xen entry upon grub menu sudo reboot Select Xen to boot upon grub entry. After login, you can verify installation via:\nsudo xl list -Z The output should looks like:\nName ID Mem VCPUs\tState\tTime(s) Security Label Domain-0 0 10240 4 r----- 800.2 system_u:system_r:dom0_t 2. Install Windows VM and get Windows symbols. You can either create a Windows VM or Linux VM as target VM to intropect from TinyVMI.\nInstall Windows as guest Create logical volumn for Windows VM:\n# create logical volumn # with # size 20G, name \u0026#39;lvwin7\u0026#39;, in volumn group \u0026#39;vg0\u0026#39; sudo lvcreate -L20G -n lvwin7 vg0 # verify the lv with its name and size sudo lvdisplay # outputs should include  --- Logical volume --- LV Path /dev/vg0/lvwin7 LV Name lvwin7 VG Name vg0 LV UUID tSN9Kk-****-****-****-****-****-afwDhx LV Write Access read/write LV Creation host, time ruisrv, 2018-06-28 13:09:38 -0400 LV Status available # open 0  LV Size 20.00 GiB Current LE 5120 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 252:8 Create a configuration file use the following template:\n# file windows7.cfg # ==== # HVM guest created from Windows ISO file # ==== type = \u0026#34;hvm\u0026#34; serial=\u0026#39;pty\u0026#39; # Guest name name = \u0026#34;win7\u0026#34; # Initial memory allocation (MB) memory = 4096 # Maximum memory (MB) # If this is greater than `memory\u0026#39; then the slack will start ballooned # (this assumes guest kernel support for ballooning) maxmem = 4096 # Number of VCPUS vcpus = 2 # Network devices vif = [ \u0026#39;type=ioemu, bridge=netbr0\u0026#39; ] # Disk Devices # change to your lv path and iso file. disk = [ \u0026#39;/dev/vg0/lvwin7,raw,xvda,w\u0026#39;,\u0026#39;/media/iso/en_windows_7_AIO_sp1_x64_x86_dvd.ISO,,hdc,cdrom\u0026#39; ] # Guest VGA console configuration, either SDL or VNC #sdl = 1 vnc = 1 vncconsole=1 boot = \u0026#34;dc\u0026#34; # uncomment this after installation, to avoid boot to iso #boot = \u0026#34;cd\u0026#34; # fix mouse cursor usbdevice=\u0026#39;tablet\u0026#39; # XSM label seclabel=\u0026#39;system_u:system_r:domU_t\u0026#39; Start VM to install Windows:\nxl create windows7.cfg If no iso file for Windows, VM image could be downloaded here. You will need to convert the Windows VM image from Virtualbox (VMWare) format to Xen Image.\nNext, we need to get Windows symbols by getting Rekall profile from Dom0:\ncd WORKDIR/ git clone https://github.com/libvmi/libvmi cd libvmi ./autogen.sh ./configure --disable-kvm Make sure the output is like the following:\nFeature | Option ----------------|--------------------------- Xen Support | --enable-xen=yes KVM Support | --enable-kvm=no File Support | --enable-file=yes Shm-snapshot | --enable-shm-snapshot=no Rekall profiles | --enable-rekall-profiles=yes ----------------|--------------------------- OS | Option ----------------|--------------------------- Windows | --enable-windows=yes Linux | --enable-linux=yes Tools | Option | Reason ----------------|---------------------------|---------------------------- Examples | --enable-examples=yes VMIFS | --enable-vmifs=yes | yes Build LibVMI:\nmake Now create Rekall profile for Windows 7 guest VM:\n# check VM is running $ sudo xl list Name ID Mem VCPUs\tStateTime(s) Domain-0 0 10239 4 r----- 2479.8 win7 6 4096 2 -b---- 84.1 $ cd WORKDIR/libvmi/examples/ $ sudo ./vmi-win-guid name win7 Windows Kernel found @ 0xc04d000 Version: 64-bit Windows 7 PE GUID: 4ce7951a5ea000 PDB GUID: 3844dbb920174967be7aa4a2c20430fa2 Kernel filename: ntkrnlmp.pdb Multi-processor without PAE Signature: 17744. Machine: 34404. # of sections: 24. \t# of symbols: 0. \tTimestamp: 1290245402. Characteristics: 34. Optional header size: 240. Optional header type: 0x20b Section 1: .text Section 2: INITKDBG Section 3: POOLMI Section 4: POOLCODE Section 5: RWEXEC Section 6: .rdata Section 7: .data Section 8: .pdata Section 9: ALMOSTRO Section 10: SPINLOCK Section 11: PAGELK Section 12: PAGE Section 13: PAGEKD Section 14: PAGEVRFY Section 15: PAGEHDLS Section 16: PAGEBGFX Section 17: PAGEVRFB Section 18: .edata Section 19: PAGEDATA Section 20: PAGEVRFC Section 21: PAGEVRFD Section 22: INIT Section 23: .rsrc Section 24: .reloc Important fields are:\nPDB GUID: 3844dbb920174967be7aa4a2c20430fa2 Kernel filename: ntkrnlmp.pdb If vmi-win-guid fails to find the Windows kernel in memory, you can use Rekall to examine ntoskrnl.exe on the disk:\n$ sudo kpartx -l /dev/vg0/lvwin7 # This will show all the partiions in the volumn, e,g vg0-lvwin7p1 : 0 204800 /dev/vg0/lvwin7 2048 vg0-lvwin7p2 : 0 41734144 /dev/0/lvwin7 206848 $ sudo kpartx -a /dev/vg0/lvwin7 $ sudo mount -o ro /dev/mapper/vg0-lvwin7p2 /mnt # might change partion to find the Windows/ folder $ sudo rekal peinfo -f /mnt/Windows/System32/ntoskrnl.exe \u0026gt; WORKDIR/peinfo.txt $ sudo umount /mnt $ sudo kpartx -d /dev/vg0/lvwin7 The generated WORKDIR/peinfo.txt file will contain the required PDB filename and GUID.\nGiven PDB file name and GUID, we can generate the Rekall profile:\n# create a target configuration directory in TinyVMI source tree. mkdir WORKDIR/xen/stubdom/tinyvmi/tiny-vmi/config/target_conf_examples/example_target_windows7_sp1_x64_new cd WORKDIR/xen/stubdom/tinyvmi/tiny-vmi/config/target_conf_examples/example_target_windows7_sp1_x64_new/ rekall fetch_pdb ntkrpamp 3844dbb920174967be7aa4a2c20430fa2 rekall parse_pdb ntkrpamp \u0026gt; windows7-sp1.rekall.json xxd -i windows7-sp1.rekall.json \u0026gt; target_libvmi_sym.c Create a C header file named \u0026ldquo;target_libvmi_sym.h\u0026rdquo; with the following content:\n#ifndef TARGET_LIBVMI_SYM_H #define TARGET_LIBVMI_SYM_H  #ifdef SYM_FILE_FROM_STRING #undef SYM_FILE_FROM_STRING #endif  #ifndef REKALL_FILE_FROM_STRING #define REKALL_FILE_FROM_STRING #endif //REKALL_FILE_FROM_STRING  #define guest_rekall_string windows7_sp1_rekall_json #define guest_rekall_string_len windows7_sp1_rekall_json_len  extern unsigned char windows7_sp1_rekall_json[]; extern unsigned int windows7_sp1_rekall_json_len; #define guest_rekall_string_SRC_FILE \u0026#34;/tiny-vmi/config/target_libvmi_s ym.c\u0026#34;#endif // TARGET_LIBVMI_COMMON_H Under the same directory, create configuration file named libvmi.conf for Windows:\nwin7 { ostype = \u0026#34;Windows\u0026#34;; rekall_profile = \u0026#34;string\u0026#34;; } And convert it into C string:\nxxd -i libvmi.conf \u0026gt; target_libvmi_conf_file.c  Then create symblic link in TinyVMI source:\n# go to dir WORKDIR/xen/stubdom/tinyvmi/tiny-vmi/config/target_conf # and remove old links cd ../../target_conf rm * # create symbolic ln -s ../target_conf_examples/example_target_windows7_sp1_x64_new/* . Update DOMAIN_NAME in file xen/stubdom/tinyvmi/include/domain_id.h. For example:\n#ifndef DOMAIN_ID_H #define DOMAIN_ID_H  #define DOMAIN_NAME \u0026#34;win7\u0026#34;  #endif // DOMAIN_ID_H Then compile and run TinyVMI\nAdjust the Xen configuration file use the template at WORKDIR/xen/stubdom/tinyvmi/domain_config:\n# file xen-src/stubdom/tinyvmi/domain_config # Change fileds accordingly # Kernel image file. kernel = \u0026#34;mini-os.gz\u0026#34; # Initial memory allocation (in megabytes) for the new domain. memory = 64 # A name for your domain. All domains must have different names. name = \u0026#34;TinyVMI\u0026#34; # network connection vif = [\u0026#39;ip=10.0.0.100,bridge=netbr0\u0026#39; ] on_crash = \u0026#39;destroy\u0026#39; seclabel=\u0026#39;system_u:system_r:domU_t\u0026#39; You might need to adjust the network configuration accordingly, i.e. giving a valid IP address and network bridge name on your domain 0.\ncd WORKDIR/xen/stubdom/tinyvmi sudo bash run.tiny.sh buildrun Then you\u0026rsquo;ll get outputs like:\nXen Minimal OS! start_info: 0xf6000(VA) nr_pages: 0x2000 shared_inf: 0xa0278000(MA) pt_base: 0xf9000(VA) .... [main] IP 0 netmask 0 gateway 0. [main] TCP/IP bringup begins. Thread \u0026quot;tcpip_thread\u0026quot;: pointer: 0x0x200000002170, stack: 0x0x2f0000 [tcpip_thread] TCP/IP bringup ends. [main] Network is ready. \u0026quot;main\u0026quot; VMI_TEST: Hello, world! VMI_TEST: main: TimeStamp: 1531894244 s 473686 us VMI_TEST: main: TimeStamp: 1531894246 s 483747 us evtchn_open() -\u0026gt; 4 xenevtchn_bind_interdomain(1, 6) = 0 VMI_TEST: LibVMI init succeeded! VMI_TEST: Waiting for events...  Create a file with the following C code in Windows 7:\n// int3.c in windows guest #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;windows.h\u0026gt; void loopasm(){ __asm__(\u0026#34;int $3\u0026#34;); } int main(){ printf(\u0026#34;INT 3 in ASM\\n\u0026#34;); for (int i = 0; i\u0026lt; 10; i++){ Sleep(2000); loopasm(); printf(\u0026#34;INT 3 LOOP %d\\n\u0026#34;, i); } printf(\u0026#34;loop done\\n\u0026#34;); return 0; } Compile and run it in Windows guest using CodeBlock (or other alternatives).\nThen on the output of TinyVMI, should like:\nWe can see the int 3 instruction running in Windows guest is caught by TinyVMI.\n"
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/install-xen-with-flask/",
	"title": "Install Xen With XSM FLASK Policy",
	"tags": [],
	"description": "",
	"content": " Overview The following steps are tested with Xen 4.10.0, other Xen versions with 4.8 and onward should also be fine. The tested host OSes include Ubuntu 16.04, and 18.04. Other Linux based system should be OK as long as they are compatitable with Xen hypervisor.\nSteps  1. Install Prerequest Packages of Xen\n 2. Install Xen\n 3. Install XSM Policy\n 4. Update GRUB Scripts with Xen XSM \n 5. Setup Xen Guest Network with WiFi or Ethernet\n 6. Install Xen Guest\n 7. Usefull Links\n    1. Install Prerequest Packages of Xen Install prerequested packages of Xen. Official list of packages can be found here. For a quick install, there is a handy script for Ubuntu 18.04 and Ubuntu 16.04. You can run it to install all the dependences directly:\n# wget https://gist.githubusercontent.com/cnlelema/5f14675364a47c6ffa7e34bb6d3ad470/raw/41cffdbc8d0c689e8d9ba78d886a215125d833d9/install-pre-ubu18-xen4.10.0.sh sudo bash install-pre-ubu18-xen4.10.0.sh  or\n# wget https://gist.githubusercontent.com/cnlelema/ca366be63573dbdaa14938107c611897/raw/ff3a4e268c1db8397ba116c695c004ac10821736/install-pre-ubu16-xen4.10.0.sh sudo bash install-pre-ubu16-xen4.10.0.sh  2. Install Xen 2.1 configure Xen Open a terminal in the source code of Xen. Run:\ncd xen-src/ ./configure --enable-systemd --enable-stubdom  2.2 enable XSM Run the following command in the terminal:\nmake -C xen menuconfig  There will be a graphical interactive interface shown in the terminal. Then choose Common Features -\u0026gt; enable XSM, with no other sub options.\n2.3 patch qemu-xen (only for Ubuntu 18.04) Due to the upgraded libc in ubuntu 18.04, some errors would come out when compiling qemu-xen in the old release of Xen. More details. We need to upgrade qemu-xen to the lastest version to match\ncd xen-src/tools/ rm -r qemu-xen/ git clone https://xenbits.xen.org/git-http/qemu-xen.git cd -  2.4 build \u0026amp; install Xen cd xen-src/ make dist -j4 # sometimes can fail with -j4, so try without it if error occurs. sudo make install  2.5 post-install operations sudo ldconfig sudo systemctl enable xen-qemu-dom0-disk-backend.service sudo systemctl enable xen-init-dom0.service sudo systemctl enable xenconsoled.service sudo systemctl enable xencommons sudo systemctl enable xen-watchdog.service  3. Install XSM Policy 3.1 compile FLASK policy cd xen-src/ make -C tools/flask/policy  3.2 copy policy to boot dir sudo mkdir /boot/flask/ sudo cp tools/flask/policy/xenpolicy-4.10.0 /boot/flask/ cd /boot/flask sudo ln -s xenpolicy-4.10.0 xenpolicy  4. Update Grub Scripts with Xen XSM WARNING 1: The following steps are only tested on Ubuntu systems. Other Linux distributions should not follow these commands unless you know what you are doing.\nWARNING 2: The following commands are changing your system booting parameters. Mistake operations can make your system unbootable. If you are not sure what you are doing, please first backup the files before change them.\n  4.1 update /etc/default/grub We need to enable XSM flask policy in boot command parameters. Add the following line to the file /etc/default/grub (backup before change: cd /etc/default \u0026amp;\u0026amp; cp grub grub.backup) :\nGRUB_CMDLINE_XEN_DEFAULT=\u0026quot;dom0_mem=3096M,max:3096M flask=enforcing\u0026quot;  Change values of dom0_mem and max accordingly. They are the actual main memory you want to allocate to Domain 0 on Xen. Make sure they are the same. For the reason, see Why should I dedicate fixed amount of memory for Xen dom0.\n4.2 update /etc/grub.d/20_linux_xen This step will change grub auto generation script to load XSM policy module automatically. Under Debian systems, you can find the grub auto-generate script at /etc/grub.d/20_linux_xen. Find the correct place you need to insert the line of module /boot/flask/\u0026lt;xenpolicy_name\u0026gt;\nwhere \u0026lt;xenpolicy_filename\u0026gt; is the XSM FLASK policy file we just compiled.\nFor example, on ubuntu system, the following line is changed:\n--- /etc/grub.d/backup/20.linux.xen\t2018-04-30 16:41:32.885068197 -0400 +++ /etc/grub.d/20_linux_xen\t2018-04-30 16:42:02.273066593 -0400 @@ -138,6 +138,7 @@  sed \u0026#34;s/^/$submenu_indentation/\u0026#34; \u0026lt;\u0026lt; EOF echo\t\u0026#39;$(echo \u0026#34;$message\u0026#34; | grub_quote)\u0026#39; module\t--nounzip ${rel_dirname}/${initrd} +\tmodule /boot/flaskpolicy/xenpolicy  EOF fi sed \u0026#34;s/^/$submenu_indentation/\u0026#34; \u0026lt;\u0026lt; EOF  4.3 generate grub files Run \u0026lsquo;sudo update-grub\u0026rsquo;. This will update your grub files (/boot/grub/grub.cfg).\n4.4 check grub file A successful update of grub should contain at least two changes in the menuentry of file /boot/grub/grub.cfg:\na) the xen kernel loading command line should have options of dom0_mem and flask. For example,\nmultiboot /boot/xen.gz placeholder dom0_mem=3096M,max:3096M flask=enforcing ${xen_rm_opts}  b). last line of the menuentry should have xenpolicy loaded. For example,\nmodule /boot/flask/xenpolicy  The following is a complete example of a menu entry definition in /boot/grub/grub.cfg auto-generated by update-grub:\n### BEGIN /etc/grub.d/20_linux_xen ### menuentry \u0026#39;Ubuntu GNU/Linux, with Xen hypervisor\u0026#39; --class ubuntu --class gnu-linux --class gnu --class os --class xen $menuentry_id_option \u0026#39; xen-gnulinux-simple-030e940e-4663-4857-bf79-682485d1507f\u0026#39; { insmod part_msdos insmod ext2 set root=\u0026#39;hd0,msdos1\u0026#39; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 030e940e-4663-4857-bf79-682485d1507f else search --no-floppy --fs-uuid --set=root 030e940e-4663-4857-b f79-682485d1507f fi echo\t\u0026#39;Loading Xen xen ...\u0026#39; if [ \u0026#34;$grub_platform\u0026#34; = \u0026#34;pc\u0026#34; -o \u0026#34;$grub_platform\u0026#34; = \u0026#34;\u0026#34; ]; then xen_rm_opts= else xen_rm_opts=\u0026#34;no-real-mode edd=off\u0026#34; fi multiboot\t/boot/xen.gz placeholder dom0_mem=3096M,max:3096M flask=enforcing ${xen_rm_opts} echo\t\u0026#39;Loading Linux 4.15.0-22-generic ...\u0026#39; module\t/boot/vmlinuz-4.15.0-22-generic placeholder root=UUID= 030e940e-4663-4857-bf79-682485d1507f ro quiet splash echo\t\u0026#39;Loading initial ramdisk ...\u0026#39; module\t--nounzip /boot/initrd.img-4.15.0-22-generic module /boot/flask/xenpolicy } 4.5 Reboot Now you can reboot the system to see whether Xen is successfully installed. If successfull, you will be able to boot with Xen hypervisor on grub menu during booting.\nAfter booted, run xl list -Z to see the result. A successful install should output something like this:\nroot@ubu18:~# xl list -Z Name ID Mem VCPUs State Time(s) Security Label Domain-0 0 3096 4 r----- 14753.8 system_u:system_r:dom0_t 5. Setup Xen Guest Network with WiFi or Ethernet If WiFi on host, follow 5.1 ~ 5.3 to set up a NAT network for guest to access Internet. If Ethernet, please jump to follow 5.4.\n5.1 Create a network bridge A bridge could be created manually by running:\nbrctl addbr natBr ifconfig natBr 10.0.0.1 up  natBr is the name of the bridge, which is defined by yourself. To automatically create the bridge at boot time in the dom0, you can use following in your /etc/network/interfaces:\nauto natBr iface natBr inet static bridge_ports none bridge_stp no address 10.0.0.1 netmask 255.255.255.0 network 10.0.0.0 broadcast 10.0.0.255  The above code will create a bridge named natBr during system boot. The ip address of the bridge is 10.0.0.1. Guest VMs connected to this bridge could get IP addresses with the prefix 10.0.0.*.\nOnce succeed, run command brctl show. The output will contain a line with defined bridge, such as:\nbridge name bridge id STP enabled interfaces natBr 8000.000000000000 no  Furthermore, ifconfig will list the bridge info as following:\nnatBr: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.0.1 netmask 255.255.255.0 broadcast 10.0.0.255 inet6 fe80::dc2a:40ff:fe7e:566d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether de:2a:40:7e:56:6d txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 134 bytes 18848 (18.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  If you see outputs above, a bridge is successfully created. Then go to next step.\n5.2 Enable forwarding and NAT change file /etc/sysctl.conf, add (or uncomment) the line:\nnet.ipv4.ip_forward = 1  run $ sudo sysctl -p /etc/sysctl.conf\nEnable forwarding and NAT(postrouting \u0026amp; masquerade) with iptables\n$ sudo iptables -A FORWARD --in-interface natBr -j ACCEPT $ sudo iptables --table nat -A POSTROUTING --out-interface \u0026lt;wifi_interface\u0026gt; -j MASQUERADE  replace \u0026lt;wifi_interface\u0026gt; with the name of your WiFi interface, such as wlps0, or lan0, etc.\n5.3 In guest: Update ( adding the bridge configs to VM). To connect the VM to the bridge ddit VM (DomU) cfg and modify the vif line (virtual interface).\nvif=['bridge=natBr,ip=10.0.0.111'] # This will connect guest to natBr with IP address 10.0.0.111  you can also leave out the ip= part and set that in the domU:\n# set static ip address in domU, file /etc/network/interfaces auto eth0 iface eth0 inet static address 10.0.0.111 netmask 255.255.255.0 gateway 10.0.0.1 dns-nameservers 8.8.8.8 8.8.4.4  5.4 If Ethernet on host: Please refer to Network Configuration Examples \u0026ndash; Debian stype bridge configuration\n6. Install Xen Guest On Ubuntu, you can follow these steps here\n7. Useful links  Offical Documentation of Xen: Xen Seucrity Modules: XSM-FLASK\n Setup Xen on Ubuntu: Xen \u0026ndash; Community Help Wiki\n Network configuration on Xen: Network Configuration Examples\n WiFi Network setup on Xen Dom0:\n Manually configuring NAT networking in Xen Network Configuration Examples \u0026ndash; Network Address Translation   "
},
{
	"uri": "https://tinyvmi.github.io/quick-start-linux/",
	"title": "Quick Start with Linux Guest",
	"tags": [],
	"description": "",
	"content": " NOTE This post shows all the comands and configuration files you need to build and run TinyVMI with Linux guest. Most of them can be used directly in your terminal on host machine(tested with Ubuntu 16.04, 18.04 as Dom0), while some fields need to be adjusted according to your build environment. For example, your working directory WORKDIR, logical volume group name vg0, iso image file path, etc.\nAcknowledgment: This post is customized for TinyVMI based on instructions at DRAKVUF.\n  1. Install Xen Compile and install Xen from given source code of xen-4.10.0, with XSM enabled. If already installed, go to Install Guest VM\nmkdir WOKRDIR cd WORKDIR/ # install prerequest for Ubuntu wget https://gist.githubusercontent.com/cnlelema/5f14675364a47c6ffa7e34bb6d3ad470/raw/41cffdbc8d0c689e8d9ba78d886a215125d833d9/install-pre-ubu18-xen4.10.0.sh sudo bash install-pre-ubu18-xen4.10.0.sh # download Xen source git clone --recurse-submodules https://github.com/tinyvmi/xen.git cd xen # configure xen ./configure --enable-stubdom --enable-systemd # enable XSM support make -C xen menuconfig # Mark option # \u0026#39;Common Features -\u0026gt; Xen Security Modules support\u0026#39;, and # suboption \u0026#39;Compile Xen with a built-in security policy\u0026#39;. # leave other option as is.  # compile \u0026amp; install Xen make dist -jN #set N to be number of cores/threads on your machine. sudo make install sudo systemctl enable xen-qemu-dom0-disk-backend.service sudo systemctl enable xen-init-dom0.service sudo systemctl enable xenconsoled.service sudo ldconfig # enable XSM flask in grub entry options  # backup sudo cp /etc/default/grub /etc/default/grub-backup # Add the following line to the file /etc/default/grub: # GRUB_CMDLINE_XEN_DEFAULT=\u0026#34;dom0_mem=3096M,max:3096M flask=enforcing\u0026#34; # This will be appended to the option of Linux kernel in the grub entry sudo sed -i \u0026#39;/GRUB_CMDLINE_LINUX=/aGRUB_CMDLINE_XEN_DEFAULT=\\\u0026#34;dom0_mem=3096M,max:3096M flask=enforcing\\\u0026#34;\u0026#39; /etc/default/grub sudo update-grub # Finally reboot and choose Xen entry upon grub menu sudo reboot Select Xen to boot upon grub entry. After login, you can verify installation via:\nsudo xl list -Z The output should looks like:\nName ID Mem VCPUs\tState\tTime(s) Security Label Domain-0 0 10240 4 r----- 800.2 system_u:system_r:dom0_t 2. Install Linux VM and get Linux symbols. You can either create a Windows VM or Linux VM as target VM to intropect from TinyVMI.\nInstall Linux as guest VM Create logical volumn for Linux VM:\n# create logical volumn # with # size 20G, name \u0026#39;lvxenubu16\u0026#39;, in volumn group \u0026#39;vg0\u0026#39; sudo lvcreate -L20G -n lvxenubu16 vg0 # verify the lv with its name and size sudo lvdisplay # outputs should include  --- Logical volume --- LV Path /dev/vg0/lvxenubu16 LV Name lvxenubu16 VG Name vg0 LV UUID iYpFmx-****-****-****-****-****-EmVmgM LV Write Access read/write LV Creation host, time ruisrv, 2017-01-24 14:58:54 -0500 LV Status available # open 0  LV Size 20.00 GiB Current LE 5120 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 252:5 Create a configuration file use the following template:\n# file ubuntu16.cfg # ==== # HVM guest created from Windows ISO file # ==== type = \u0026#34;hvm\u0026#34; serial=\u0026#39;pty\u0026#39; # Guest name name = \u0026#34;xen16a\u0026#34; # Initial memory allocation (MB) memory = 4096 # Maximum memory (MB) maxmem = 4096 # Number of VCPUS vcpus = 2 # Network devices vif = [ \u0026#39;ip=10.0.0.2,bridge=netbr0\u0026#39; ] # Disk Devices # change to your lv path and iso file. disk = [ \u0026#39;/dev/vg0/lvxenubu16,raw,xvda,w\u0026#39;,\u0026#39;/media/iso/ubuntu-16.04-desktop-amd64.iso,,hdc,cdrom\u0026#39; ] # Guest VGA console configuration, either SDL or VNC #sdl = 1 vnc = 1 vncconsole=1 boot = \u0026#34;dc\u0026#34; # uncomment this after installation, to avoid boot to iso #boot = \u0026#34;cd\u0026#34; # fix mouse cursor usbdevice=\u0026#39;tablet\u0026#39; # XSM label seclabel=\u0026#39;system_u:system_r:domU_t\u0026#39; Start VM to install Ubuntu 16.04:\nxl create ubuntu16.cfg Setup Linux Symbols After installaltion, get Linux kernel symbols and read offsets by running offset finder tool in guest. The offset finder tool is from the LibVMI.\nFirst mount the logical volumn of the guest VM.\n# assume the guest is installed in /dev/vg0/lvxenubu16 sudo fdisk -l /dev/vg0/lvxenubu16 output will show the sector size and start sector of the first partition:\nDisk /dev/vg0/lvxenubu16: 20 GiB, 21474836480 bytes, 41943040 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disklabel type: dos Disk identifier: 0x488fbb03 Device Boot Start End Sectors Size Id Type /dev/vg0/lvxenubu16p1 * 2048 39942143 39940096 19G 83 Linux /dev/vg0/lvxenubu16p2 39942144 41940991 1998848 976M 82 Linux  Here we can mount the guest image using offset of start sector (2048) multiplied by sector size (512):\nxl destroy xen16a xl list # make sure guest is not running  mount_offset=$(echo \u0026#34;2048*512\u0026#34; | bc) echo $mount_offset sudo mount -o loop,offset=$mount_offset /dev/vg0/lvxenubu16 mnt/ # Then copy libvmi/tools/linux-offset-finder to guest VM, and copy system map file to Dom0.  sudo cp -r libvmi/tools/linux-offset-finder /mnt/root/ # create directory to store system map and configuration files # [suggested:] adjust the folder name according to your guest kernel version mkdir example_target_u16_4.4.0_101_x64_test cp /mnt/boot/System.map-4.4.0-101-generic example_target_u16_4.4.0_101_x64_test/ sudo umount /mnt Then convert system map to C string:\ncd example_target_u16_4.4.0_101_x64_test/ xxd -i System.map-4.4.0-101-generic \u0026gt; target_libvmi_sym.c Then, create new file target_libvmi_sym.h with the following code:\n// file: target_libvmi_sym.h #ifndef TARGET_LIBVMI_CONF_SYM_H #define TARGET_LIBVMI_CONF_SYM_H  /** * define linux_system_map_string for Linux * change this if use another system map * all the System_map_* variables are declared here, and * defined at file /tiny-vmi/config/target_libvmi_sym.c * the definition is generated by xxd command which coverts a file * to ASCII string codes: xxd -i System_map_* */ #ifndef SYM_FILE_FROM_STRING #define SYM_FILE_FROM_STRING #endif  #ifdef REKALL_FILE_FROM_STRING #undef REKALL_FILE_FROM_STRING #endif  #define linux_system_map_string System_map_4_4_0_101_generic #define linux_system_map_string_len System_map_4_4_0_101_generic_len  extern unsigned char System_map_4_4_0_101_generic[]; extern unsigned int System_map_4_4_0_101_generic_len; #define linux_system_map_string_SRC_FILE \u0026#34;string\u0026#34;  #endif // TARGET_LIBVMI_CONF_SYSMAP_H Replace variable System_map_4_4_0_101_generic and System_map_4_4_0_101_generic_len as needed. You can run head target_libvmi_sym.c and tail target_libvmi_sym.c to find the names.\nNow boot linux, in guest VM, run with root:\nroot@guest: $ cd /root/linux-offset-finder/ root@guest: $ make root@guest: $ insmod findoffsets.ko root@guest: $ rmmod findoffsets root@guest: $ dmesg | tail # output should be similar to [ 490.682638] findoffsets: module verification failed: signature and/or required key missing - tainting kernel [ 490.683879] Module FindOffsets loaded. [ 490.683879] [ 490.683891] [domain name] { [ 490.683896] ostype = \u0026#34;Linux\u0026#34;; [ 490.683901] sysmap = \u0026#34;[insert path here]\u0026#34;; [ 490.683907] linux_name = 0x600; [ 490.683912] linux_tasks = 0x350; [ 490.683917] linux_mm = 0x3a0; [ 490.683922] linux_pid = 0x448; [ 490.683927] linux_pgd = 0x40; [ 490.683931] } Copy the offset output into the WORKDIR/example_target_u16_4.4.0_101_x64_test/libvmi.conf file in dom0, be sure to update the domain name:\n# file example_target_u16_4.4.0_101_x64_test/libvmi.conf xen16a{ ostype = \u0026#34;Linux\u0026#34;; sysmap = \u0026#34;string\u0026#34;; linux_name = 0x600; linux_tasks = 0x350; linux_mm = 0x3a0; linux_pid = 0x448; linux_pgd = 0x40; } Next, convert the configuration file into C string.\ncd example_target_u16_4.4.0_101_x64_test/ xxd -i libvmi.conf \u0026gt; target_libvmi_conf_file.c  Then mv the configuration files to TinyVMI and create symblic link in TinyVMI source:\nmv example_target_u16_4.4.0_101_x64_test/ xen/stubdom/tinyvmi/tiny-vmi/config/target_conf_examples/ # go to dir WORKDIR/xen/stubdom/tinyvmi/tiny-vmi/config/target_conf # and remove old links cd xen/stubdom/tinyvmi/tiny-vmi/config/target_conf/ rm * # create symbolic ln -s ../target_conf_examples/example_target_u16_4.4.0_101_x64_test/* . Update DOMAIN_NAME in file xen/stubdom/tinyvmi/include/domain_id.h. For example:\n#ifndef DOMAIN_ID_H #define DOMAIN_ID_H  #define DOMAIN_NAME \u0026#34;xen16a\u0026#34;  #endif // DOMAIN_ID_H 3. Compile and run TinyVMI Now we are ready to compile and run TinyVMI\nAdjust the Xen configuration file use the template at WORKDIR/xen/stubdom/tinyvmi/domain_config:\n# file xen-src/stubdom/tinyvmi/domain_config # Change fileds accordingly # Kernel image file. kernel = \u0026#34;mini-os.gz\u0026#34; # Initial memory allocation (in megabytes) for the new domain. memory = 64 # A name for your domain. All domains must have different names. name = \u0026#34;TinyVMI\u0026#34; # network connection vif = [\u0026#39;ip=10.0.0.100,bridge=netbr0\u0026#39; ] on_crash = \u0026#39;destroy\u0026#39; seclabel=\u0026#39;system_u:system_r:domU_t\u0026#39; You might need to adjust the network configuration accordingly, i.e. giving a valid IP address and network bridge name on your domain 0.\ncd WORKDIR/xen/stubdom/tinyvmi sudo bash run.tiny.sh buildrun Then you\u0026rsquo;ll get outputs like:\nXen Minimal OS! start_info: 0xf6000(VA) nr_pages: 0x2000 shared_inf: 0xa0278000(MA) pt_base: 0xf9000(VA) .... [main] IP 0 netmask 0 gateway 0. [main] TCP/IP bringup begins. Thread \u0026quot;tcpip_thread\u0026quot;: pointer: 0x0x200000002170, stack: 0x0x2f0000 [tcpip_thread] TCP/IP bringup ends. [main] Network is ready. \u0026quot;main\u0026quot; VMI_TEST: Hello, world! VMI_TEST: main: TimeStamp: 1531894244 s 473686 us VMI_TEST: main: TimeStamp: 1531894246 s 483747 us evtchn_open() -\u0026gt; 4 xenevtchn_bind_interdomain(1, 6) = 0 VMI_TEST: LibVMI init succeeded! VMI_TEST: Waiting for events...  Create a file with the following C code in Linux guest VM:\n// int3.c in Linux guest #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; void loopasm(){ __asm__(\u0026#34;int $3\u0026#34;); } int main(){ printf(\u0026#34;INT 3 in ASM\\n\u0026#34;); for (int i = 0; i\u0026lt; 10; i++){ Sleep(2); loopasm(); printf(\u0026#34;INT 3 LOOP %d\\n\u0026#34;, i); } printf(\u0026#34;loop done\\n\u0026#34;); return 0; } Compile and run it:\ngcc int3.c -o int3 ./int3  Then on the output of TinyVMI, should like:\nWe can see the int 3 instruction running in Linux guest is caught by TinyVMI.\n"
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/",
	"title": "Configure TinyVMI",
	"tags": [],
	"description": "",
	"content": "Before configure TinyVMI, it is required to install Xen with FLASK enabled and to have a guest VM to be monitored by TinyVMI. To do so, see instructions here.\nSteps to Configure TinyVMI  Update XSM FLASK Policy\n Update Makefile under xen-src/stubdom/\n Get Target Guest Kernel Info (Linux)\n Configure TinyVMI with Target Guest Info\n    "
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/update-xsm-flask-policy/",
	"title": "Update XSM FLASK Policy",
	"tags": [],
	"description": "",
	"content": " NOTE  Before this step, it is required to install Xen with FLASK enabled and to have a guest VM to be monitored by TinyVMI. To do so, see instructions here.\n The following assumes the XSM FLASK policy is booted from file /boot/flask/xenpolicy. However, the file name can be changed to other ones as shown here. Or can be dynamically loaded after booting via xl loadpolicy \u0026lt;xenpolicy_file\u0026gt;.\n    1. change policy in /tools/flask/policy/modules/ dom0.te domU.te  In general, those two files defines privileges granted to dom0 and domU, respectively. In order to grant enough privileges to TinyVMI as well as dom0, those two files are tentatively changed. An example setup for Xen-4.10.0 can be found from our github repo.\nDANGER In our proof-of-concept experiment, TinyVMI and target VM are both labeled with domU for simplicity. However, this is a risky setup where all domUs have same privilege of introspecting other domUs on the same Xen hypervisor. Therefore, this should never be used for any commercial or regular usage on personal PCs.\n  2. build policy apt-get install checkpolicy cd xen-src/ make -C tools/flask/policy  3. load policy You can either simply to load it dynamically via:\nsudo xl loadpolicy tools/flask/policy/xenpolicy-4.10.0  OR you can make the system boot with the newest policy by\nsudo cp tools/flask/policy/xenpolicy-4.10.0 /boot/flask/  and change grub options accordingly (see Update Grub Scripts with Xen XSM).\n"
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/run-tinyvmi/",
	"title": "Build and Run TinyVMI",
	"tags": [],
	"description": "",
	"content": " Tips You can directly run a handy bash script in tinyvmi/ directory:\nTo build and run TinyVMI altogether in a single command:\ncd xen-src/stubdom/tinyvmi sudo bash run.tiny.sh build  Or to only make TinyVMI without creating VM:\ncd xen-src/stubdom/tinyvmi sudo bash run.tiny.sh make Or to only run TinyVMI without rebuild:\ncd xen-src/stubdom/tinyvmi sudo bash run.tiny.sh For more details, see the following steps.\n  Build TinyVMI # cd ./stubdom/ # make tinyvmi-stubdom  Grant Xenstore Permission to LibVMI Command xenstore-chmod can be used to change xenstore permissions. ( xenstore-ls -p to see the current permissions)\nPermission of a Xenstore directory/key is defined by format of LD, where L is a letter for the type of permission and D is the corresponding domain ID. In order to get the domain ID of TinyVMI, you can first create the VM and pause it immediately (within 2 seconds as the main function will wait for 2 seconds before start executing its actual workload codes), then get the ID via xl list or xl domid TinyVMI. For example:\n# start VM and pause immediately cd ./stubdom/minios-x86_64-tinyvmi xl create ../tinyvmi/domain_config \u0026amp; \u0026amp;\u0026amp; \\ xl pause TinyVMI \u0026amp;\u0026amp; echo \u0026#34;Domain ID of TinyVMI: $(xl domid \u0026#39;TinyVMI\u0026#39;)\u0026#34; Then, you could run\n# change permission of the directory \u0026#39;/local/domain\u0026#39; recursively $ xenstore-chmod -r \u0026#39;/local/domain\u0026#39; rN This will allow TinyVMI to read the entire directory \u0026lsquo;/local/domain\u0026rsquo; in Xenstore.\nRun TinyVMI Now you can resume the TinyVMI by running xl unpause TinyVMI.\n"
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/",
	"title": "Step by Step",
	"tags": [],
	"description": "",
	"content": "Here is an overview of all steps we need to build and run TinyVMI. The following will introduce all the changes to the original Xen-4.10.0 source code in order to run TinyVMI:\n Install Xen with XSM FLASK Enabled.\n Configure TinyVMI\na) Update XSM FLASK Policy\nb) Update Stubdom Makefile\nc) Update Mini-OS Makefile\nd) Get Target Guest Kernel Info (Linux)\ne) Configure TinyVMI with Target Guest Info\n Build and Run TinyVMI\n  "
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/update-stubdom-makefile/",
	"title": "Update Stubdom Makefile",
	"tags": [],
	"description": "",
	"content": "TinyVMI is developed as a stubdom running on top of Xen hypervisor.\nThe following changes are made to xen-src/stubdom/Makefile to support the compilation of TinyVMI with the necessary targets and library dependences (full makefile example):\n--- stubdom/Makefile.old\t2017-12-13 06:37:59.000000000 -0500 +++ stubdom/Makefile\t2018-07-02 19:46:48.999545378 -0400 @@ -61,7 +61,7 @@  TARGET_LDFLAGS += -nostdlib -L$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf/lib -TARGETS=$(STUBDOM_TARGETS) +TARGETS=$(STUBDOM_TARGETS) c xenstore tinyvmi  STUBDOMPATH=\u0026#34;stubdompath.sh\u0026#34; genpath-target = $(call buildmakevars2file,$(STUBDOMPATH)) @@ -101,6 +101,103 @@  $(MAKE) DESTDIR= \u0026amp;\u0026amp; \\ $(MAKE) DESTDIR= install ) +############## +# Cross-json-c +############## +# https://s3.amazonaws.com/json-c_releases/releases/json-c-0.13.1.tar.gz + +JSON_C_URL=\u0026#34;https://s3.amazonaws.com/json-c_releases/releases\u0026#34; +JSON_C_VERSION=0.13 + +# TARGET_CFLAGS += -Wno-error=implicit-fallthrough -Wno-error=declaration-after-statement +# TARGET_CFLAGS += -Wno-error=strict-prototypes +# TARGET_CFLAGS += -Wno-error=implicit-function-declaration +TARGET_CFLAGS += -Wno-error + +json-c-$(JSON_C_VERSION).tar.gz: +\t$(FETCHER) $@ $(JSON_C_URL)/$@ + +json-c-$(XEN_TARGET_ARCH): json-c-$(JSON_C_VERSION).tar.gz +\ttar xzf $\u0026lt; +\tmv json-c-$(JSON_C_VERSION) $@ + +JSON_C_STAMPFILE=$(CROSS_ROOT)/$(GNU_TARGET_ARCH)-xen-elf/lib/libjson-c.a +.PHONY: cross-json-c +cross-json-c: $(JSON_C_STAMPFILE) +$(JSON_C_STAMPFILE): json-c-$(XEN_TARGET_ARCH) $(NEWLIB_STAMPFILE) +\t( cd json-c-$(XEN_TARGET_ARCH) \u0026amp;\u0026amp; \\ +\tsh autogen.sh \u0026amp;\u0026amp; \\ +\tCFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)\u0026#34; CC=$(CC) \\ +\t./configure --disable-shared --disable-threading \\ +\t--prefix=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf \\ +\t--exec-prefix=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf \\ +\t--host=$(GNU_TARGET_ARCH)-xen-elf \u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= \u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= install ) + +############## +# Cross-jansson +############## +# http://www.digip.org/jansson/releases/jansson-2.11.tar.gz +JANSSON_URL=\u0026#34;http://www.digip.org/jansson/releases\u0026#34; +JANSSON_VERSION=2.11 + +# TARGET_CFLAGS += -Wno-error=implicit-fallthrough -Wno-error=declaration-after-statement +# TARGET_CFLAGS += -Wno-error=strict-prototypes +# TARGET_CFLAGS += -Wno-error=implicit-function-declaration +TARGET_CFLAGS += -Wno-error + +jansson-$(JANSSON_VERSION).tar.gz: +\t$(FETCHER) $@ $(JANSSON_URL)/$@ + +jansson-$(XEN_TARGET_ARCH): jansson-$(JANSSON_VERSION).tar.gz +\ttar xzf $\u0026lt; +\tmv jansson-$(JANSSON_VERSION) $@ + +JANSSON_STAMPFILE=$(CROSS_ROOT)/$(GNU_TARGET_ARCH)-xen-elf/lib/libjansson.a +.PHONY: cross-jansson +cross-jansson: $(JANSSON_STAMPFILE) +$(JANSSON_STAMPFILE): jansson-$(XEN_TARGET_ARCH) $(NEWLIB_STAMPFILE) +\t( cd jansson-$(XEN_TARGET_ARCH) \u0026amp;\u0026amp; \\ +\tCFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)\u0026#34; CC=$(CC) \\ +\t./configure --prefix=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf \\ +\t--host=$(GNU_TARGET_ARCH)-xen-elf \u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= \u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= install ) + +############## +# Cross-iconv +############## +# https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.15.tar.gz +ICONV_URL=\u0026#34;https://ftp.gnu.org/pub/gnu/libiconv\u0026#34; +ICONV_VERSION=1.15 + +# TARGET_CFLAGS += -Wno-error=implicit-fallthrough -Wno-error=declaration-after-statement +# TARGET_CFLAGS += -Wno-error=strict-prototypes +# TARGET_CFLAGS += -Wno-error=implicit-function-declaration +TARGET_CFLAGS += -Wno-error + +libiconv-$(ICONV_VERSION).tar.gz: +\t$(FETCHER) $@ $(ICONV_URL)/$@ + +iconv-$(XEN_TARGET_ARCH): libiconv-$(ICONV_VERSION).tar.gz +\ttar xzf $\u0026lt; +\tmv libiconv-$(ICONV_VERSION) $@ + +ICONV_STAMPFILE=$(CROSS_ROOT)/$(GNU_TARGET_ARCH)-xen-elf/lib/libiconv.a +.PHONY: cross-iconv +cross-iconv: $(ICONV_STAMPFILE) +$(ICONV_STAMPFILE): iconv-$(XEN_TARGET_ARCH) $(NEWLIB_STAMPFILE) +\t( cd iconv-$(XEN_TARGET_ARCH) \u0026amp;\u0026amp; \\ +\tCFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)\u0026#34; CC=$(CC) \\ +\t./configure --prefix=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf \\ +\t--host=$(GNU_TARGET_ARCH)-xen-elf \\ +\t--build=x86_64-linux-gnu \\ +\t--enable-static \\ +\t\u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= \u0026amp;\u0026amp; \\ +\t$(MAKE) DESTDIR= install ) +  ############ # Cross-zlib ############ @@ -493,6 +590,20 @@  c: $(CROSS_ROOT) c-minios-config.mk CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(shell cat c-minios-config.mk)\u0026#34; CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; $(MAKE) DESTDIR= -C $@ LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) + +### +# tinyvmi based on c but no glib, 2014.10.27 +### + +tinyvmi-minios-config.mk: $(CURDIR)/tinyvmi/minios.cfg +\tMINIOS_CONFIG=\u0026#34;$\u0026lt;\u0026#34; CONFIG_FILE=\u0026#34;$(CURDIR)/$@\u0026#34; $(MAKE) DESTDIR= -C $(MINI_OS) config + +.PHONY: tinyvmi +# tinyvmi: cross-iconv cross-jansson cross-json-c cross-newlib $(CROSS_ROOT) tinyvmi-minios-config.mk +tinyvmi: cross-jansson cross-json-c cross-newlib $(CROSS_ROOT) tinyvmi-minios-config.mk +\tCPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(shell cat c-minios-config.mk)\u0026#34; CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; $(MAKE) DESTDIR= -C $@ LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) + +  ###### # VTPM ###### @@ -565,6 +676,13 @@  c-stubdom: mini-os-$(XEN_TARGET_ARCH)-c lwip-$(XEN_TARGET_ARCH) libxc c DEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/c/minios.cfg\u0026#34; $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/c/main.a + +## added 20180305, lele +.PHONY: tinyvmi-stubdom +tinyvmi-stubdom: mini-os-$(XEN_TARGET_ARCH)-tinyvmi lwip-$(XEN_TARGET_ARCH) libxc xenstore tinyvmi +\t@echo \u0026#34;LELE:target $@ :L563\u0026#34; +\tDEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/tinyvmi/minios.cfg\u0026#34; $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/tinyvmi/main.a +  .PHONY: vtpm-stubdom vtpm-stubdom: mini-os-$(XEN_TARGET_ARCH)-vtpm vtpm DEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/vtpm/minios.cfg\u0026#34; $(MAKE) -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; APP_OBJS=\u0026#34;$(CURDIR)/vtpm/vtpm.a\u0026#34; APP_LDLIBS=\u0026#34;-ltpm -ltpm_crypto -lgmp -lpolarssl\u0026#34; @@ -604,6 +722,8 @@  install-c: c-stubdom +install-tinyvmi: tinyvmi-stubdom +  install-caml: caml-stubdom install-xenstore: xenstore-stubdom @@ -658,6 +778,7 @@  clean: rm -fr mini-os-$(XEN_TARGET_ARCH)-ioemu rm -fr mini-os-$(XEN_TARGET_ARCH)-c +\trm -fr mini-os-$(XEN_TARGET_ARCH)-tinyvmi #lele, 2018.02.18  rm -fr mini-os-$(XEN_TARGET_ARCH)-caml rm -fr mini-os-$(XEN_TARGET_ARCH)-grub rm -fr mini-os-$(XEN_TARGET_ARCH)-xenstore  "
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/update-minios-makefile/",
	"title": "Update Mini-OS Makefile",
	"tags": [],
	"description": "Update Mini-OS Makefile",
	"content": "Mini-OS is compiled with a minimal number of libraries essentially for its limited kernel functions. TinyVMI requires more libraries, including json-c, jansson.\nAll libraries in Mini-OS need to be statically compiled and linked into the tiny kernel. Under Xen development environment, we could statically compile the library in stubdom\u0026rsquo;s makefile as shown in the previous step. To link the library, the following changes need to be made in the Makefile of Mini-OS source code:\n--- extras/mini-os/Makefile.old\t2017-10-20 06:50:35.000000000 -0400 +++ extras/mini-os/Makefile\t2018-07-02 19:48:24.655456301 -0400 @@ -142,6 +142,9 @@  LIBS += $(XEN_ROOT)/stubdom/libxc-$(MINIOS_TARGET_ARCH)/libxenctrl.a LIBS += $(XEN_ROOT)/stubdom/libxc-$(MINIOS_TARGET_ARCH)/libxenguest.a endif +# APP_LDLIBS += -liconv +APP_LDLIBS += -ljansson +APP_LDLIBS += -ljson-c  APP_LDLIBS += -lpci APP_LDLIBS += -lz APP_LDLIBS += -lm  "
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/get-target-guest-info-linux/",
	"title": "Get Target Guest Info (Linux)",
	"tags": [],
	"description": "",
	"content": " Start Target VM with FLASK label According to our setup in Update XSM FLASK Policy, a VM labeled with domU has priviledges to intropsect another domU\u0026rsquo;s physical memory. Now we can label TinyVMI with domU to grant the VM of TinyVMI with those privileges.\nChange xl config file for the target VM. Add the following line to this file:\nseclabel='system_u:system_r:domU_t'  An example configuration file:\n# Kernel image file. kernel = \u0026quot;mini-os.gz\u0026quot; # Initial memory allocation (in megabytes) for the new domain. memory = 64 # A name for your domain. All domains must have different names. name = \u0026quot;TinyVMI\u0026quot; on_crash = 'destroy' seclabel='system_u:system_r:domU_t'  Now you can start target VM by running xl create \u0026lt;domain_config_file\u0026gt;\nGet Guest Kernel Offsets NOTE This method is totally derived from how LibVMI get info from guest kernel.\n  Download the linux-offset-finder from LibVMI repo. Then you can use this program to get the offset values needed for the ~/etc/libvmi.conf file. To use, follow the steps below.\n Copy the files in this directory to the target VM. Log into the target VM as root. cd into the directory with this program, then run make. insmod findoffsets.ko if you are logged into the console, you will see the output. Otherwise, see /var/log/syslog or dmesg for the output. rmmod findoffsets copy the output into your ~/etc/libvmi.conf file in dom0, be sure to update the domain name and sysmap location.  Get Guest Kernel Sysmap Copy the system map file to dom0. For example, on a guest VM running with Ubuntu 16.04, you can find system map file at /boot/Sysmap.map-\u0026lt;kernel_version\u0026gt;, then copy it in ~/etc/Sysmap.map-\u0026lt;kernel_version\u0026gt;. The current kernel_verion can be got by run uname -r.\nSummary Now we have the following info from the target guest VM:\n target VM name and ID. ~/etc/libvmi.conf. Acquired by linux-offset-finder in target VM. ~/etc/System.map-\u0026lt;kernel_version\u0026gt;. Copied from /boot/System.map-* on target VM.  Next, we will use those info to configure TinyVMI.\n  "
},
{
	"uri": "https://tinyvmi.github.io/step-by-step/configuration/configure-tinyvmi-with-target-guest-info/",
	"title": "Configure TinyVMI with Target Info",
	"tags": [],
	"description": "",
	"content": " 1. Compile libvmi.conf run\nxxd -i ~/etc/libvmi.conf \u0026gt; ~/etc/target_libvmi_conf_file.c  2. Compile system map run\nxxd -i ~/etc/System.map-\\\u0026lt;kernel_version\u0026gt; \u0026gt; ~/etc/target_libvmi_sym.c  Then, copy the following code to new file ~/etc/target_libvmi_sym.h:\n#ifndef TARGET_LIBVMI_CONF_SYM_H #define TARGET_LIBVMI_CONF_SYM_H  /** * define system_map_string for Linux * change this if use another system map * all the System_map_* variables are declared here, and * defined at file /tiny-vmi/config/target_conf/target_libvmi_sym.c * the definition is generated by xxd command which coverts a file * to ASCII string codes: xxd -i System_map_* */ #define linux_system_map_string System_map_4_4_0_101_generic #define linux_system_map_string_len System_map_4_4_0_101_generic_len  extern unsigned char System_map_4_4_0_101_generic[]; extern unsigned int System_map_4_4_0_101_generic_len; #define linux_system_map_string_SRC_FILE \u0026#34;string\u0026#34;  #endif // TARGET_LIBVMI_CONF_SYM_H In the above file, replace variable System_map_4_4_0_101_generic and System_map_4_4_0_101_generic_len with your own variable names generated in the last step. You can run head ~/etc/target_libvmi_sym.c or tail ~/etc/target_libvmi_sym.c to find the names.\n3. Compile with TinyVMI Then, create a new directory in tinyvmi/tiny-vmi/config/target_conf_examples/, say my_conf_dir/, and run:\ncd xen-src/stubdom/tinyvmi/tiny-vmi/config/target_conf_examples/my_conf_dir/ cp ~/etc/libvmi.conf \\  ~/etc/System.map* \\  ~/etc/target_* \\  . cd ../../target_conf/ rm * ln -s ../target_conf_examples/my_conf_dir/* . 4. Update domain_id.h Currently, TinyVMI cannot convert domain string name to domain ID by querying Xenstore. Therefore, a hardcoded domain ID is required. To do so, change DOMAIN_ID and DOMAIN_NAME macro definition in file tinyvmi/include/domain_id.h. For example:\n#ifndef DOMAIN_ID_H #define DOMAIN_ID_H  #define DOMAIN_ID 1  #define DOMAIN_NAME \u0026#34;xen16a\u0026#34;  #endif // DOMAIN_ID_H"
},
{
	"uri": "https://tinyvmi.github.io/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tinyvmi.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tinyvmi.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tinyvmi.github.io/",
	"title": "TinyVMI Documentation",
	"tags": [],
	"description": "",
	"content": " TinyVMI TinyVMI   is a lightweight implementation of LibVMI   in a minimized operating system.\nTinyVMI was open sourced under a GSoC project. A blog was posted to track its development progress (not maintained).  Contribute to this documentation Feel free to update this content, just click the improve this page link displayed on bottom right of each page, and pullrequest it.\nDocumentation website This current documentation has been statically generated with Hugo, source code is available at GitHub  \n"
}]