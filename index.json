[
{
	"uri": "https://tinyvmi.github.io/get-started/configuration/update-xsm-flask-policy/",
	"title": "Update XSM FLASK Policy",
	"tags": [],
	"description": "",
	"content": " NOTE  Before this step, it is required to install Xen with FLASK enabled and to have a guest VM to be monitored by TinyVMI. To do so, see instructions here.\n The following assumes the XSM FLASK policy is booted from file /boot/flask/xenpolicy. However, the file name can be changed to other ones as shown here. Or can be dynamically loaded after booting via xl loadpolicy \u0026lt;xenpolicy_file\u0026gt;.\n    1. change policy in /tools/flask/policy/modules/ dom0.te domU.te  In general, those two files defines privileges granted to dom0 and domU, respectively. In order to grant enough privileges to TinyVMI as well as dom0, those two files are tentatively changed. An example setup for Xen-4.10.0 can be found from our github repo.\nDANGER In our proof-of-concept experiment, TinyVMI and target VM are both labeled with domU for simplicity. However, this is a risky setup where all domUs have same privilege of introspecting other domUs on the same Xen hypervisor. Therefore, this should never be used for any commercial or regular usage on personal PCs.\n  2. build policy apt-get install checkpolicy cd xen-src/ make -C tools/flask/policy  3. load policy You can either simply to load it dynamically via:\nsudo xl loadpolicy tools/flask/policy/xenpolicy-4.10.0  OR you can make the system boot with the newest policy by\nsudo cp tools/flask/policy/xenpolicy-4.10.0 /boot/flask/  and change grub options accordingly (see Update Grub Scripts with Xen XSM).\n"
},
{
	"uri": "https://tinyvmi.github.io/get-started/install-xen-with-flask/",
	"title": "Install Xen With FLASK",
	"tags": [],
	"description": "",
	"content": " Overview The following steps are tested with Xen 4.10.0, other Xen versions with 4.8 and onward should also be fine. The tested host OSes include Ubuntu 16.04, and 18.04. Other Linux based system should be OK as long as they are compatitable with Xen hypervisor.\nSteps  1. Install Prerequest Packages of Xen\n 2. Install Xen\n 3. Install XSM Policy\n 4. Update GRUB Scripts with Xen XSM \n 5. Setup Xen Guest Network with WiFi or Ethernet\n 6. Install Xen Guest\n 7. Usefull Links\n    1. Install Prerequest Packages of Xen Install prerequested packages of Xen. Official list of packages can be found here. For a quick install, there is a handy script for Ubuntu 18.04 and Ubuntu 16.04. You can run it to install all the dependences directly:\n# wget https://gist.githubusercontent.com/cnlelema/5f14675364a47c6ffa7e34bb6d3ad470/raw/41cffdbc8d0c689e8d9ba78d886a215125d833d9/install-pre-ubu18-xen4.10.0.sh sudo bash install-pre-ubu18-xen4.10.0.sh  or\n# wget https://gist.githubusercontent.com/cnlelema/ca366be63573dbdaa14938107c611897/raw/ff3a4e268c1db8397ba116c695c004ac10821736/install-pre-ubu16-xen4.10.0.sh sudo bash install-pre-ubu16-xen4.10.0.sh  2. Install Xen 2.1 configure Xen Open a terminal in the source code of Xen. Run:\ncd xen-src/ ./configure --enable-systemd --enable-stubdom  2.2 enable XSM Run the following command in the terminal:\nmake -C xen menuconfig  There will be a graphical interactive interface shown in the terminal. Then choose Common Features -\u0026gt; enable XSM, with no other sub options.\n2.3 patch qemu-xen (only for Ubuntu 18.04) Due to the upgraded libc in ubuntu 18.04, some errors would come out when compiling qemu-xen in the old release of Xen. More details. We need to upgrade qemu-xen to the lastest version to match\ncd xen-src/tools/ rm -r qemu-xen/ git clone https://xenbits.xen.org/git-http/qemu-xen.git cd -  2.4 build \u0026amp; install Xen cd xen-src/ make dist -j4 # sometimes can fail with -j4, so try without it if error occurs. sudo make install  2.5 post-install operations sudo ldconfig sudo systemctl enable xen-qemu-dom0-disk-backend.service sudo systemctl enable xen-init-dom0.service sudo systemctl enable xenconsoled.service sudo systemctl enable xencommons sudo systemctl enable xen-watchdog.service  3. Install XSM Policy 3.1 compile FLASK policy cd xen-src/ make -C tools/flask/policy  3.2 copy policy to boot dir sudo mkdir /boot/flask/ sudo cp tools/flask/policy/xenpolicy-4.10.0 /boot/flask/ cd /boot/flask sudo ln -s xenpolicy-4.10.0 xenpolicy  4. Update Grub Scripts with Xen XSM WARNING 1: The following steps are only tested on Ubuntu systems. Other Linux distributions should not follow these commands unless you know what you are doing.\nWARNING 2: The following commands are changing your system booting parameters. Mistake operations can make your system unbootable. If you are not sure what you are doing, please first backup the files before change them.\n  4.1 update /etc/default/grub We need to enable XSM flask policy in boot command parameters. Add the following line to the file /etc/default/grub (backup before change: cd /etc/default \u0026amp;\u0026amp; cp grub grub.backup) :\nGRUB_CMDLINE_XEN_DEFAULT=\u0026quot;dom0_mem=3096M,max:3096M flask=enforcing\u0026quot;  Change values of dom0_mem and max accordingly. They are the actual main memory you want to allocate to Domain 0 on Xen. Make sure they are the same. For the reason, see Why should I dedicate fixed amount of memory for Xen dom0.\n4.2 update /etc/grub.d/20_linux_xen This step will change grub auto generation script to load XSM policy module automatically. Under Debian systems, you can find the grub auto-generate script at /etc/grub.d/20_linux_xen. Find the correct place you need to insert the line of module /boot/flask/\u0026lt;xenpolicy_name\u0026gt;\nwhere \u0026lt;xenpolicy_filename\u0026gt; is the XSM FLASK policy file we just compiled.\nFor example, on ubuntu system, the following line is changed:\n--- /etc/grub.d/backup/20.linux.xen\t2018-04-30 16:41:32.885068197 -0400 +++ /etc/grub.d/20_linux_xen\t2018-04-30 16:42:02.273066593 -0400 @@ -138,6 +138,7 @@  sed \u0026#34;s/^/$submenu_indentation/\u0026#34; \u0026lt;\u0026lt; EOF echo\t\u0026#39;$(echo \u0026#34;$message\u0026#34; | grub_quote)\u0026#39; module\t--nounzip ${rel_dirname}/${initrd} +\tmodule /boot/flaskpolicy/xenpolicy  EOF fi sed \u0026#34;s/^/$submenu_indentation/\u0026#34; \u0026lt;\u0026lt; EOF  4.3 generate grub files Run \u0026lsquo;sudo update-grub\u0026rsquo;. This will update your grub files (/boot/grub/grub.cfg).\n4.4 check grub file A successful update of grub should contain at least two changes in the menuentry of file /boot/grub/grub.cfg:\na) the xen kernel loading command line should have options of dom0_mem and flask. For example,\nmultiboot /boot/xen.gz placeholder dom0_mem=3096M,max:3096M flask=enforcing ${xen_rm_opts}  b). last line of the menuentry should have xenpolicy loaded. For example,\nmodule /boot/flask/xenpolicy  The following is a complete example of a menu entry definition in /boot/grub/grub.cfg auto-generated by update-grub:\n### BEGIN /etc/grub.d/20_linux_xen ### menuentry \u0026#39;Ubuntu GNU/Linux, with Xen hypervisor\u0026#39; --class ubuntu --class gnu-linux --class gnu --class os --class xen $menuentry_id_option \u0026#39; xen-gnulinux-simple-030e940e-4663-4857-bf79-682485d1507f\u0026#39; { insmod part_msdos insmod ext2 set root=\u0026#39;hd0,msdos1\u0026#39; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 030e940e-4663-4857-bf79-682485d1507f else search --no-floppy --fs-uuid --set=root 030e940e-4663-4857-b f79-682485d1507f fi echo\t\u0026#39;Loading Xen xen ...\u0026#39; if [ \u0026#34;$grub_platform\u0026#34; = \u0026#34;pc\u0026#34; -o \u0026#34;$grub_platform\u0026#34; = \u0026#34;\u0026#34; ]; then xen_rm_opts= else xen_rm_opts=\u0026#34;no-real-mode edd=off\u0026#34; fi multiboot\t/boot/xen.gz placeholder dom0_mem=3096M,max:3096M flask=enforcing ${xen_rm_opts} echo\t\u0026#39;Loading Linux 4.15.0-22-generic ...\u0026#39; module\t/boot/vmlinuz-4.15.0-22-generic placeholder root=UUID= 030e940e-4663-4857-bf79-682485d1507f ro quiet splash echo\t\u0026#39;Loading initial ramdisk ...\u0026#39; module\t--nounzip /boot/initrd.img-4.15.0-22-generic module /boot/flask/xenpolicy } 4.5 Reboot Now you can reboot the system to see whether Xen is successfully installed. If successfull, you will be able to boot with Xen hypervisor on grub menu during booting.\nAfter booted, run xl list -Z to see the result. A successful install should output something like this:\nroot@ubu18:~# xl list -Z Name ID Mem VCPUs State Time(s) Security Label Domain-0 0 3096 4 r----- 14753.8 system_u:system_r:dom0_t 5. Setup Xen Guest Network with WiFi or Ethernet 5.1 If WiFi on host: 5.1.1 Create a network bridge A bridge could be created manually by running:\nbrctl addbr natBr ifconfig natBr 10.0.0.1 up  natBr is the name of the bridge, which is defined by yourself. To automatically create the bridge at boot time in the dom0, you can use following in your /etc/network/interfaces:\nauto natBr iface natBr inet static bridge_ports none bridge_stp no address 10.0.0.1 netmask 255.255.255.0 network 10.0.0.0 broadcast 10.0.0.255  The above code will create a bridge named natBr during system boot. The ip address of the bridge is 10.0.0.1. Guest VMs connected to this bridge could get IP addresses with the prefix 10.0.0.*.\nOnce succeed, run command brctl show. The output will contain a line with defined bridge, such as:\nbridge name bridge id STP enabled interfaces natBr 8000.000000000000 no  Furthermore, ifconfig will list the bridge info as following:\nnatBr: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.0.0.1 netmask 255.255.255.0 broadcast 10.0.0.255 inet6 fe80::dc2a:40ff:fe7e:566d prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether de:2a:40:7e:56:6d txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 134 bytes 18848 (18.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0  If you see outputs above, a bridge is successfully created. Then go to next step.\n5.1.2 Enable forwarding and NAT change file /etc/sysctl.conf, add (or uncomment) the line:\nnet.ipv4.ip_forward = 1  run $ sudo sysctl -p /etc/sysctl.conf\nEnable forwarding and NAT(postrouting \u0026amp; masquerade) with iptables\n$ sudo iptables -A FORWARD --in-interface natBr -j ACCEPT $ sudo iptables --table nat -A POSTROUTING --out-interface \u0026lt;wifi_interface\u0026gt; -j MASQUERADE  replace \u0026lt;wifi_interface\u0026gt; with the name of your WiFi interface, such as wlps0, or lan0, etc.\n5.1.3 In guest: Update ( adding the bridge configs to VM). To connect the VM to the bridge ddit VM (DomU) cfg and modify the vif line (virtual interface).\nvif=['bridge=natBr,ip=10.0.0.111'] # This will connect guest to natBr with IP address 10.0.0.111  you can also leave out the ip= part and set that in the domU:\n# set static ip address in domU, file /etc/network/interfaces auto eth0 iface eth0 inet static address 10.0.0.111 netmask 255.255.255.0 gateway 10.0.0.1 dns-nameservers 8.8.8.8 8.8.4.4  5.2 If Ethernet on host: Please refer to Network Configuration Examples \u0026ndash; Debian stype bridge configuration\n6. Install Xen Guest On Ubuntu, you can follow these steps here\n7. Useful links  Offical Documentation of Xen: Xen Seucrity Modules: XSM-FLASK\n Setup Xen on Ubuntu: Xen \u0026ndash; Community Help Wiki\n Network configuration on Xen: Network Configuration Examples\n WiFi Network setup on Xen Dom0:\n Manually configuring NAT networking in Xen Network Configuration Examples \u0026ndash; Network Address Translation   "
},
{
	"uri": "https://tinyvmi.github.io/get-started/configuration/update-stubdom-makefile/",
	"title": "Update Stubdom Makefile",
	"tags": [],
	"description": "",
	"content": "The following changes are made to xen-src/stubdom/Makefile to support the compilation of TinyVMI in Xen source tree (full makefile):\n--- stubdom/Makefile.old\t2017-12-13 06:37:59.000000000 -0500 +++ stubdom/Makefile\t2018-05-10 16:44:54.053957803 -0400 @@ -61,7 +61,7 @@  TARGET_LDFLAGS += -nostdlib -L$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf/lib -TARGETS=$(STUBDOM_TARGETS) +TARGETS=$(STUBDOM_TARGETS) c xenstore tinyvmi  STUBDOMPATH=\u0026#34;stubdompath.sh\u0026#34; genpath-target = $(call buildmakevars2file,$(STUBDOMPATH)) @@ -493,6 +493,16 @@  c: $(CROSS_ROOT) c-minios-config.mk CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(shell cat c-minios-config.mk)\u0026#34; CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; $(MAKE) DESTDIR= -C $@ LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) + +### +# tinyvmi based on c but no glib, 2014.10.27 +### + +.PHONY: tinyvmi +tinyvmi: cross-newlib +\tCPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS) $(shell cat c-minios-config.mk)\u0026#34; CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; $(MAKE) DESTDIR= -C $@ LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) + +  ###### # VTPM ###### @@ -565,6 +575,13 @@  c-stubdom: mini-os-$(XEN_TARGET_ARCH)-c lwip-$(XEN_TARGET_ARCH) libxc c DEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/c/minios.cfg\u0026#34; $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/c/main.a + +## added 20180305, lele +.PHONY: tinyvmi-stubdom +tinyvmi-stubdom: mini-os-$(XEN_TARGET_ARCH)-tinyvmi lwip-$(XEN_TARGET_ARCH) libxc xenstore tinyvmi +\t@echo \u0026#34;LELE:target $@ :L563\u0026#34; +\tDEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/tinyvmi/minios.cfg\u0026#34; $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/tinyvmi/main.a +  .PHONY: vtpm-stubdom vtpm-stubdom: mini-os-$(XEN_TARGET_ARCH)-vtpm vtpm DEF_CPPFLAGS=\u0026#34;$(TARGET_CPPFLAGS)\u0026#34; DEF_CFLAGS=\u0026#34;$(TARGET_CFLAGS)\u0026#34; DEF_LDFLAGS=\u0026#34;$(TARGET_LDFLAGS)\u0026#34; MINIOS_CONFIG=\u0026#34;$(CURDIR)/vtpm/minios.cfg\u0026#34; $(MAKE) -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$\u0026lt; APP_OBJS=\u0026#34;$(CURDIR)/vtpm/vtpm.a\u0026#34; APP_LDLIBS=\u0026#34;-ltpm -ltpm_crypto -lgmp -lpolarssl\u0026#34; @@ -604,6 +621,8 @@  install-c: c-stubdom +install-tinyvmi: tinyvmi-stubdom +  install-caml: caml-stubdom install-xenstore: xenstore-stubdom @@ -658,6 +677,7 @@  clean: rm -fr mini-os-$(XEN_TARGET_ARCH)-ioemu rm -fr mini-os-$(XEN_TARGET_ARCH)-c +\trm -fr mini-os-$(XEN_TARGET_ARCH)-tinyvmi #lele, 2018.02.18  rm -fr mini-os-$(XEN_TARGET_ARCH)-caml rm -fr mini-os-$(XEN_TARGET_ARCH)-grub rm -fr mini-os-$(XEN_TARGET_ARCH)-xenstore  "
},
{
	"uri": "https://tinyvmi.github.io/get-started/configuration/",
	"title": "Configure TinyVMI",
	"tags": [],
	"description": "",
	"content": "Before configure TinyVMI, it is required to install Xen with FLASK enabled and to have a guest VM to be monitored by TinyVMI. To do so, see instructions here.\nSteps to Configure TinyVMI  Update XSM FLASK Policy\n Update Makefile under xen-src/stubdom/\n Get Target Guest Kernel Info\n Configure TinyVMI with Target Guest Info\n    "
},
{
	"uri": "https://tinyvmi.github.io/get-started/configuration/get-target-guest-info/",
	"title": "Get Target Guest Info",
	"tags": [],
	"description": "",
	"content": " Start Target VM with FLASK label According to our setup in Update XSM FLASK Policy, a VM labeled with domU has priviledges to intropsect another domU\u0026rsquo;s physical memory. Now we can label TinyVMI with domU to grant the VM of TinyVMI with those privileges.\nChange xl config file for the target VM. Add the following line to this file:\nseclabel='system_u:system_r:domU_t'  Now you can start target VM by running xl create \u0026lt;domain_config_file\u0026gt;\nGet Guest Kernel Offsets NOTE This method is totally derived from how LibVMI get info from guest kernel.\n  Download the linux-offset-finder from LibVMI repo. Then you can use this program to get the offset values needed for the ~/etc/libvmi.conf file. To use, follow the steps below.\n Copy the files in this directory to the target VM. Log into the target VM as root. cd into the directory with this program, then run make. insmod findoffsets.ko if you are logged into the console, you will see the output. Otherwise, see /var/log/syslog or dmesg for the output. rmmod findoffsets copy the output into your ~/etc/libvmi.conf file in dom0, be sure to update the domain name and sysmap location.  Get Guest Kernel Sysmap Copy the system map file to dom0. For example, on a guest VM running with Ubuntu 16.04, you can find system map file at /boot/Sysmap.map-\u0026lt;kernel_version\u0026gt;, then copy it in ~/etc/Sysmap.map-\u0026lt;kernel_version\u0026gt;. The current kernel_verion can be got by run uname -r.\nSummary Now we have the following info from the target guest VM:\n target VM name and ID. ~/etc/libvmi.conf. Acquired by linux-offset-finder in target VM. ~/etc/System.map-\u0026lt;kernel_version\u0026gt;. Copied from /boot/System.map-* on target VM.  Next, we will use those info to configure TinyVMI.\n  "
},
{
	"uri": "https://tinyvmi.github.io/get-started/run-tinyvmi/",
	"title": "Build and Run TinyVMI",
	"tags": [],
	"description": "",
	"content": " Build TinyVMI # cd ./stubdom/ # make tinyvmi-stubdom  Label VM of TinyVMI Change xl config file for the VM of TinyVMI. A sample could be found in xen-src/extras/mini-os/domain_config. Add the following line to this file:\nseclabel='system_u:system_r:domU_t'  Run TinyVMI Now you can start vm by running xl create \u0026lt;domain_config_file\u0026gt;. For example,\n# cd minios-x86_64-tinyvmi # xl create -c ../../extras/mini-os/domain_config  Tips You can also directly run a handy bash script in tinyvmi/ directory:\ncd xen-src/stubdom/tinyvmi sudo bash run.tiny.sh    "
},
{
	"uri": "https://tinyvmi.github.io/get-started/configuration/configure-tinyvmi-with-target-guest-info/",
	"title": "Configure TinyVMI with Target Info",
	"tags": [],
	"description": "",
	"content": " 1. Compile libvmi.conf run\nxxd -i ~/etc/libvmi.conf \u0026gt; ~/etc/target_libvmi_conf_file.c  2. Compile system map run\nxxd -i ~/etc/System.map-\\\u0026lt;kernel_version\u0026gt; \u0026gt; ~/etc/target_libvmi_sysmap.c  Then, copy the following code to new file ~/etc/target_libvmi_sysmap.h:\n#ifndef TARGET_LIBVMI_CONF_SYSMAP_H  #define TARGET_LIBVMI_CONF_SYSMAP_H  /** * define system_map_string for Linux * change this if use another system map * all the System_map_* variables are declared here, and * defined at file /tiny-vmi/config/libvmi_conf_file_sysmap_*.c * the definition is generated by xxd command which coverts a file * to ASCII string codes: xxd -i System_map_* */ #define linux_system_map_string System_map_4_4_0_101_generic  #define linux_system_map_string_len System_map_4_4_0_101_generic_len  extern unsigned char System_map_4_4_0_101_generic[]; extern unsigned int System_map_4_4_0_101_generic_len; #define linux_system_map_string_SRC_FILE \u0026#34;/tiny-vmi/config/target_libvmi_sysmap.c\u0026#34;  #endif // TARGET_LIBVMI_CONF_SYSMAP_H In the above file, replace variable System_map_4_4_0_101_generic and System_map_4_4_0_101_generic_len with your own variable names generated in the last step. You can run head ~/etc/target_libvmi_sysmap.c or tail ~/etc/target_libvmi_sysmap.c to find the names.\n3. Compile with TinyVMI Then, create a new directory in tinyvmi/tiny-vmi/config/target_conf_examples/, say my_conf_dir/, and run:\ncd xen-src/stubdom/tinyvmi/tiny-vmi/config/ cp ~/etc/libvmi.conf \\ ~/etc/System.map* \\ ~/etc/target_* \\ ./target_conf_examples/my_conf_dir/ cd target_conf/ rm * ln -s ../target_conf_examples/my_conf_dir/* .  4. Update domain_id.h Currently, TinyVMI cannot convert domain string name to domain ID by querying Xenstore. Therefore, a hardcoded domain ID is required. To do so, change DOMAIN_ID and DOMAIN_NAME macro definition in file tinyvmi/include/domain_id.h. For example:\n#ifndef DOMAIN_ID_H  #define DOMAIN_ID_H  #define DOMAIN_ID 1  #define DOMAIN_NAME \u0026#34;xen16a\u0026#34;  #endif // DOMAIN_ID_H\n"
},
{
	"uri": "https://tinyvmi.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tinyvmi.github.io/get-started/",
	"title": "Get Started",
	"tags": [],
	"description": "",
	"content": "Welcome! Now let\u0026rsquo;s start to learn how to install and run TinyVMI on Xen Hypervisor.\nFirst, we need Install Xen with FLASK.\n"
},
{
	"uri": "https://tinyvmi.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tinyvmi.github.io/",
	"title": "TinyVMI Documentation",
	"tags": [],
	"description": "",
	"content": " TinyVMI TinyVMI   is a lightweight implementation of LibVMI   in a minimized operating system.\nTinyVMI is now being developed under a GSoC project. A blog is maintained to track its development progress.  Contribute to this documentation Feel free to update this content, just click the Edit this page link displayed on bottom right of each page, and pullrequest it.\nDocumentation website This current documentation has been statically generated with Hugo, source code is available here at GitHub  \n"
}]